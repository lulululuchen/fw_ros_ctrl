/*
 *    This file was auto-generated by ACADO Code Generation Tool.
 *    
 *    ACADO Code Generation tool is a sub-package of ACADO toolkit --
 *    A Toolkit for Automatic Control and Dynamic Optimization.
 *    Copyright (C) 2008-2014 by Boris Houska, Hans Joachim Ferreau,
 *    Milan Vukov, Rien Quirynen, KU Leuven.
 *    Developed within the Optimization in Engineering Center (OPTEC)
 *    under supervision of Moritz Diehl. All rights reserved.
 *    
 *    ACADO Toolkit is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *    
 *    ACADO Toolkit is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *    
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with ACADO Toolkit; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *    
 */


/*
 * ACADO OCP solver wrapper header.
 */
 
#ifndef acado_SOLVER_SFUNCTION
#define acado_SOLVER_SFUNCTION

/* Include the common header. */
#include "acado_common.h"

/** Internal data structure for communicating with the solver
  * NOTE: Do not change order of the fields here
  */
typedef struct
{
	real_t x[(ACADO_N + 1) * ACADO_NX];
	
#if ACADO_NXA
	real_t z[ACADO_N * ACADO_NXA];
#endif

	real_t u[ACADO_N * ACADO_NU];

#if ACADO_NOD
	real_t od[(ACADO_N + 1) * ACADO_NOD];
#endif

	real_t y[ACADO_N * ACADO_NY];
	real_t yN[ACADO_NYN];
	
#if ACADO_WEIGHTING_MATRICES_TYPE == 1
	real_t W[ACADO_NY * ACADO_NY];
	real_t WN[ACADO_NYN * ACADO_NYN];
#elif ACADO_WEIGHTING_MATRICES_TYPE == 2
	real_t W[ACADO_N * ACADO_NY * ACADO_NY];
	real_t WN[ACADO_NYN * ACADO_NYN];
#endif

#if ACADO_USE_ARRIVAL_COST == 1
	real_t xAC[ ACADO_NX ];
	real_t SAC[ACADO_NX * ACADO_NX];
	real_t WL[ACADO_NX * ACADO_NX];
#endif
	
#if ACADO_INITIAL_STATE_FIXED
	real_t x0[ ACADO_NX ];
#endif /* #if ACADO_INITIAL_STATE_FIXED */

#if ACADO_COMPUTE_COVARIANCE_MATRIX == 1
	real_t sigmaN[ACADO_NX * ACADO_NX];
#endif

} acadodata;

/** Input data structure for the ACADO OCP solver. */
typedef struct
{
	int control;			/**< Control flag. */
	int shifting; 			/**< Shifting strategy. */
	int initialization;		/**< Initialization flag. */
	acadodata data;	        /**< Input data. */
} acadoinput;

/** Output data structure for the ACADO OCP solver. */
typedef struct
{
	int status;				/**< Status (ATM from the QP solver). */
	int nIterations;        /**< @ iteration of the QP solver. */
	real_t kktValue;		/**< KKT value. */
	real_t objValue;		/**< Objective value. */
	real_t execTime;		/**< Execution time. */
	acadodata data;	        /**< Output data. */
} acadooutput;

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

/** The step function of the solver. */
void acado_step(
	acadoinput*  inData,	/**< Input data. */
	acadooutput* outData	/**< Output data. */
	);

/** Initialization of the solver. */
void acado_initialize( void );

/** Cleanup of the solver. */
void acado_cleanup( void );

#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif /* acado_SOLVER_SFUNCTION */
